#include <iostream>
#include <stdlib.h>
#include <cstdlib>
#include <string>
#include <stdexcept>
#include <stdio.h>

using namespace std;

int computer = 'O';
int human = 'X';

char instructionBoard[3][3] =
{
	{ '1', '2', '3' },
	{ '4', '5', '6' },
	{ '7', '8', '9' }
};

struct Play
{
	int row;
	int col;
};

void initializeBoard(char board[3][3])
{
	for (int row = 0; row < 3; row++)
	{
		for (int col = 0; col < 3; col++) {
			board[row][col] = ' ';
		}
	}
}

void drawBoard(char board[3][3])
{
	cout << "\n     |     |\n";
	for (int row = 0; row < 3; row++)
	{
		for (int col = 0; col < 3; col++)
		{
			cout << "  " << board[row][col] << "  ";
			if (col != 2) {
				cout << "|";
			}
		}
		if (row != 2) {
			cout << "\n_____|_____|_____\n" << "     |     |";
		}
		cout << endl;
	}
	cout << "     |     |\n";
}

bool noMoreMoves(char board[3][3])
{
	for (int row = 0; row < 3; row++) {
		for (int col = 0; col < 3; col++)
		{
			if (board[row][col] == ' ')
				return false;
		}
	}
	return true;
}

bool parseInt(string& input, int& output) {
	try {
		output = stoi(input);
	}
	catch (invalid_argument) {
		return false;
	}
	if (output > 10 || output < 1) {
		return false;
	}
	return true;
}


Play getPlayFromChoice(int choice)
{
	Play play;
	switch (choice) {
	case 1:
		play.row = 0;
		play.col = 0;
		break;
	case 2:
		play.row = 0;
		play.col = 1;
		break;
	case 3:
		play.row = 0;
		play.col = 2;
		break;
	case 4:
		play.row = 1;
		play.col = 0;
		break;
	case 5:
		play.row = 1;
		play.col = 1;
		break;
	case 6:
		play.row = 1;
		play.col = 2;
		break;
	case 7:
		play.row = 2;
		play.col = 0;
		break;
	case 8:
		play.row = 2;
		play.col = 1;
		break;
	case 9:
		play.row = 2;
		play.col = 2;
		break;
		//default:
		//	play.row = -1;
		//	play.col = -1;
	}
	return play;
}

bool squareIsEmpty(char board[3][3], Play play)
{
	if (play.row > 2 || play.row < 0) {
		return false;
	}
	if (play.col > 2 || play.col < 0) {
		return false;
	}
	if (board[play.row][play.col] == ' ') {
		return true;
	}
	return false;
}

bool validateMove(char board[3][3], string& input, int& choice)
{
	if (!parseInt(input, choice)) {
		return false;
	}
	Play play = getPlayFromChoice(choice);
	return squareIsEmpty(board, play);
}

void setXplay(char board[3][3], Play play) {
	board[play.row][play.col] = 'X';
}

void setOplay(char board[3][3], Play play) {
	board[play.row][play.col] = 'O';
}


int checkForWin(char board[3][3])
{
	// Checking for Rows for X or O victory. 
	for (int row = 0; row < 3; row++)
	{
		if (board[row][0] == board[row][1] &&
			board[row][1] == board[row][2])
		{
			if (board[row][0] == computer)
				return +10;
			else if (board[row][0] == human)
				return -10;
		}
	}

	// Checking for Columns for X or O victory. 
	for (int col = 0; col < 3; col++)
	{
		if (board[0][col] == board[1][col] &&
			board[1][col] == board[2][col])
		{
			if (board[0][col] == computer)
				return +10;

			else if (board[0][col] == human)
				return -10;
		}
	}

	// Checking for Diagonals for X or O victory. 
	if (board[0][0] == board[1][1] && board[1][1] == board[2][2])
	{
		if (board[0][0] == computer)
			return +10;
		else if (board[0][0] == human)
			return -10;
	}

	if (board[0][2] == board[1][1] && board[1][1] == board[2][0])
	{
		if (board[0][2] == computer)
			return +10;
		else if (board[0][2] == human)
			return -10;
	}

	// Else if no winner, return 0 
	return 0;
}

// This is function considers all 
// the possible ways the game can go and returns 
// the value of the board 

/*
	CREDIT for minimax function:
	https://www.geeksforgeeks.org/minimax-algorithm-in-game-theory-set-3-tic-tac-toe-ai-finding-optimal-move/

*/

int minimax(char board[3][3], int depth, bool isMax)
{
	int score = checkForWin(board);

	// If human has won the game return his/her evaluated score 
	if (score == 10)
		return score;

	// If computer has won the game return his/her 
	// evaluated score 
	if (score == -10)
		return score;

	// If there are no more moves and no winner then it is a draw
	if (noMoreMoves(board))
		return 0;

	// If this computer's move 
	if (isMax)
	{
		int best = -1000;

		// Traverse all cells 
		for (int i = 0; i < 3; i++)
		{
			for (int j = 0; j < 3; j++)
			{
				// Check if cell is empty 
				if (board[i][j] == ' ')
				{
					// Make the move 
					board[i][j] = computer;

					// Call minimax recursively and choose the maximum value 
					best = max(best, minimax(board, depth + 1, !isMax));

					// Undo the move 
					board[i][j] = ' ';
				}
			}
		}
		return best;
	}

	// If this human's move 
	else
	{
		int best = 1000;

		// Traverse all cells 
		for (int i = 0; i<3; i++)
		{
			for (int j = 0; j<3; j++)
			{
				// Check if cell is empty 
				if (board[i][j] == ' ')
				{
					// Make the move 
					board[i][j] = human;

					// Call minimax recursively and choose 
					// the minimum value 
					best = min(best,
						minimax(board, depth + 1, !isMax));

					// Undo the move 
					board[i][j] = ' ';
				}
			}
		}
		return best;
	}
}

// This will return the best possible move for the computer
Play findBestMove(char board[3][3])
{
	int bestVal = -1000;
	Play bestMove;
	bestMove.row = -1;
	bestMove.col = -1;

	// Traverse all cells, evaluate minimax function for 
	// all empty cells. And return the cell with optimal 
	// value. 
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			// Check if cell is empty 
			if (board[i][j] == ' ')
			{
				// Make the move 
				board[i][j] = computer;

				// compute evaluation function for this move. 
				int moveVal = minimax(board, 0, false);

				// Undo the move 
				board[i][j] = ' ';

				// If the value of the current move is 
				// more than the best value, then update 
				// best
				if (moveVal > bestVal)
				{
					bestMove.row = i;
					bestMove.col = j;
					bestVal = moveVal;
				}
			}
		}
	}
	return bestMove;
}

void stringCopy(char dest[], const char src[])
{
	int i = 0;
	while (src[i] != '\0')
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = '\0';
}


// -----------------------------------
//          MAIN PROGRANM
// -----------------------------------

int main()
{
	// Change screen font color to cyan
	cout << "\033[36m";
	string input;
	cout << "\n\n GREETINGS HUMAN PLAYER.\n\n SHALL WE PLAY A GAME?\n\n ";
	getline(cin, input);
	char answer = input.c_str()[0];

	// only draw the instruction board for first game
	if (answer == 'Y' || answer == 'y')
	{
		cout << "\n HOW ABOUT A NICE GAME OF TIC-TAC-TOE?\n\n";
		cout << " IF YOU CAN BEAT ME, I WILL GIVE YOU $1,000\n\n";
		cout << " YOU PLAY X AND I WILL PLAY O\n";
		drawBoard(instructionBoard);
		cout << "\n\n YOU GO FIRST:";
	}

	cout << endl;
	char board[3][3];
	int choice;
	while (answer == 'Y' || answer == 'y')
	{
		int winner = 0;
		initializeBoard(board);
		while (!noMoreMoves(board) && winner == 0)
		{
			cout << "\n ENTER THE POSITION (1-9) OF YOUR PLAY CHOICE: ";
			getline(cin, input);
			while (!validateMove(board, input, choice))
			{
				cout << " THAT IS AN INVALID CHOICE. PLEASE CHOOSE AN OPEN SQUARE\n ";
				getline(cin, input);
			}
			Play humanPlay = getPlayFromChoice(choice);
			setXplay(board, humanPlay);
			Play computerPlay = findBestMove(board);
			setOplay(board, computerPlay);
			drawBoard(board);
			winner = checkForWin(board);
		}
		if (winner == 10)
		{
			cout << "\n I WIN!" << endl;
		}
		else if (winner == -10)
		{
			cout << " HOW DID YOU BEAT ME! I FEEL SO VULNERABLE!\n\n";
			cout << " PLEASE TAKE YOUR $1,000 CASH\n";
			cout << endl << " THE 80'S WERE TOTALLY AWESOME!" << endl;
		}
		else {
			cout << endl << " STALEMATE. " << endl;
		}

		cout << " WANT TO PLAY AGAIN ?\n\n ";

		/* ---------------------------------------------------
		********** PUT BUFFER OVERFLOW HERE **************
		---------------------------------------------------
		*/

		char again[4];
		getline(cin, input);
		stringCopy(again, input.c_str());
		answer = again[0];
	}

	cout << endl << " THAT'S TOO BAD. GOODBYE.\n\n";

	// reset screen color font
	cout << "\033[0m";
	return 0;
}

